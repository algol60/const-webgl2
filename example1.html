<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title addtitledoc="" false>WebGL2 example1</title>
  <link rel="icon" href="favicon-16x16.png">
  <!-- <link type="text/css" href="resources/webgl-tutorials.css" rel="stylesheet" /> -->
  <style>
    body {
      margin: 0;
    }

    canvas {
      display: block;
      /* prevents scrollbar */
      width: 100vw;
      height: 100vh;
      background-color: red;
    }
  </style>
</head>

<body>
  <!-- <div class="description">
    Uses a few utility functions so there's much less code.
    </div> -->
  <canvas id="canvas"></canvas>
</body>
<script src="resources/twgl-full.min.js"></script>
<script src="resources/m4.js"></script>
<script src="resources/texture-utils.js"></script>
<script src="resources/chroma.min.js"></script>
<script>
  'use strict';

  const vs = `#version 300 es
uniform mat4 u_worldViewProjection;

in vec4 a_position;
in vec2 a_texcoord;
in float a_image;
flat out float v_image;

out vec2 v_texCoord;

void main() {
  v_image = a_image;

  v_texCoord = a_texcoord;
  vec4 v_position = (u_worldViewProjection * a_position);
  gl_Position = v_position;
}
`;

  const fs = `#version 300 es
precision highp float;

in vec2 v_texCoord;

// uniform sampler2D u_diffuse;
flat in float v_image;

out vec4 outColor;

void main() {
  // vec4 diffuseColor = texture(u_diffuse, v_texCoord);

  // if (diffuseColor.a==0.0) {
  //   discard;
  // }
  // outColor = diffuseColor;

  if (v_image==0.0) {
    outColor = vec4(1,0,0,1);
  } else if (v_image==1.0) {
    outColor = vec4(0,1,0,0.5);
  } else if (v_image==2.0) {
    outColor = vec4(0,0,1,1);
  } else {
    outColor = vec4(1,1,1,1);
  }
}
`;

  function main() {
    const rand = function (min, max) {
      if (max === undefined) {
        max = min;
        min = 0;
      }
      return min + Math.random() * (max - min);
    };

    const randInt = function (range) {
      return Math.floor(Math.random() * range);
    };

    const numObjects = 100;
    console.log(`numObjects: ${numObjects}`);
    const pos = [];
    const img = [];
    // const tex = [];
    // const ind = [];

    const nradius = 10;
    for (let i = 0; i < numObjects; i++) {
      const objRadius = nradius * Math.sqrt(numObjects);
      const x = rand(objRadius) - objRadius/2;
      const y = rand(objRadius) - objRadius/2;
      const z = rand(objRadius) - objRadius/2;

      // pos.push(x, y, z,  x + 10, y, z,  x, y + 10, z,  x + 10, y + 10, z);
      // const c = i%3;
      // img.push(c,c,c,c);
      // // img.push(2,2,2,2);
      // tex.push(0, 0, 0, 1, 1, 0, 1, 1);
      // ind.push(0, 1, 2, 1, 2, 3);

      pos.push(x, y, z,  x + nradius, y, z,  x, y + nradius, z,
                         x + nradius, y, z,  x, y + nradius, z,  x + nradius, y + nradius, z);
      const c = i%3;
      img.push(c, c, c, c, c, c);
      // img.push(2,2,2,2);
      // tex.push(0, 0, 0, 1, 1, 0,
                    //  0, 1, 1, 0, 1, 1);
      // ind.push(0, 1, 2, 1, 2, 3);

    }

    // Get A WebGL context
    /** @type {HTMLCanvasElement} */
    const canvas = document.querySelector("#canvas");

    // No alpha in the backbuffer: see https://webglfundamentals.org/webgl/lessons/webgl-and-alpha.html.
    //
    const gl = canvas.getContext("webgl2", { alpha: false });
    if (!gl) {
      return;
    }

    // Tell the twgl to match position with a_position, n
    // normal with a_normal etc..
    twgl.setAttributePrefix("a_");

    // an indexed quad
    //   var arrays = {
    //      position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },
    //      texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },
    //      indices:  { numComponents: 3, data: [0, 1, 2, 1, 2, 3],                       },
    //   };

    const arrays = {
      position: {numComponents:3, data:pos},
      image:    {numComponents:1, data:img},
      // texcoord: {numComponents:2, data:tex},
      // indices:  {numComponents:3, data:ind},
    }
    const bufferInfo = twgl.createBufferInfoFromArrays(gl, arrays);

    // setup GLSL program
    const program = twgl.createProgramFromSources(gl, [vs, fs]);
    const uniformSetters = twgl.createUniformSetters(gl, program);
    const attribSetters = twgl.createAttributeSetters(gl, program);

    const vao = twgl.createVAOFromBufferInfo(
      gl, attribSetters, bufferInfo);

    function degToRad(d) {
      return d * Math.PI / 180;
    }

    const fieldOfViewRadians = degToRad(60);

    const uniformsThatAreTheSameForAllObjects = {
      u_worldViewProjection: m4.identity(),
      u_viewInverse:           m4.identity(),
    };

    // var uniformsThatAreComputedForEachObject = {
    //   u_worldViewProjection: m4.identity(),
    //   u_world: m4.identity(),
    //   u_worldInverseTranspose: m4.identity(),
    // };

    const textures = [
      textureUtils.makeStripeTexture(gl, { color1: "#F00", color2: "#700", }),
      textureUtils.makeCheckerTexture(gl, { color1: "#070", color2: "#0F0", }),
      textureUtils.makeCircleTexture(gl, { color1: 'rgba(255,255,255,0.0)', color2: '#00F', }),
      // textureUtils.makeCircleTexture(gl, { color1: 'rgba(255,0,0,0)', color2: "#CCC", }),
    ];

    // const objects = [];
    // for (var ii = 0; ii < 1; ++ii) {
    //   objects.push({
    //     radius: 0,//rand(numObjects / 2),
    //     xRotation: rand(Math.PI * 2),
    //     yRotation: rand(Math.PI),
    //     // materialUniforms: {
    //     //   // u_diffuse:               textures[randInt(textures.length)],
    //     //   u_diffuse: textures[ii % textures.length],
    //     // },
    //   });
    // }

    // Compute the camera's matrix using look at.
    //
    const camDist = 200;
    const cameraPosition = [0, 0, camDist];
    const target = [0, 0, 0];
    const up = [0, 1, 0];

    requestAnimationFrame(drawScene);

    // Draw the scene.
    function drawScene(time) {
      time = 5 + time * 0.001;

      twgl.resizeCanvasToDisplaySize(gl.canvas);

      // Tell WebGL how to convert from clip space to pixels
      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

      gl.enable(gl.DEPTH_TEST);

      // Compute the projection matrix
      const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
      const projectionMatrix =
        m4.perspective(fieldOfViewRadians, aspect, 1, 2000);

      // // Compute the camera's matrix using look at.
      // const camDist = 200;
      // var cameraPosition = [0, 0, camDist];
      // var target = [0, 0, 0];
      // var up = [0, 1, 0];
      cameraPosition[0] = Math.sin(time) * camDist;
      cameraPosition[2] = Math.cos(time) * camDist;
      const cameraMatrix = m4.lookAt(cameraPosition, target, up, uniformsThatAreTheSameForAllObjects.u_viewInverse);

      // Make a view matrix from the camera matrix.
      const viewMatrix = m4.inverse(cameraMatrix);

      const viewProjectionMatrix = m4.multiply(projectionMatrix, viewMatrix);
      const worldMatrix = m4.identity();
      m4.multiply(viewProjectionMatrix, worldMatrix, uniformsThatAreTheSameForAllObjects.u_worldViewProjection);

      gl.useProgram(program);

      // Setup all the needed attributes.
      gl.bindVertexArray(vao);

      // Set the uniforms that are the same for all objects.
      twgl.setUniforms(uniformSetters, uniformsThatAreTheSameForAllObjects);

      // // Draw objects

      // Compute a position for this object based on the time.
      // var worldMatrix = m4.identity();
      // worldMatrix = m4.yRotate(worldMatrix, object.yRotation * time);
      // worldMatrix = m4.xRotate(worldMatrix, object.xRotation * time);
      // worldMatrix = m4.translate(worldMatrix, 0, 0, object.radius,
      //   uniformsThatAreComputedForEachObject.u_world);

      // // Multiply the matrices.
      // m4.multiply(viewProjectionMatrix, worldMatrix, uniformsThatAreComputedForEachObject.u_worldViewProjection);
      // m4.transpose(m4.inverse(worldMatrix), uniformsThatAreComputedForEachObject.u_worldInverseTranspose);

      // // Set the uniforms we just computed
      // twgl.setUniforms(uniformSetters, uniformsThatAreComputedForEachObject);

      // // Set the uniforms that are specific to the this object.
      // twgl.setUniforms(uniformSetters, object.materialUniforms);

      // Draw the geometry.
      // gl.drawElements(gl.TRIANGLES, bufferInfo.numElements, gl.UNSIGNED_SHORT, 0);
      gl.drawArrays(gl.TRIANGLES, 0, bufferInfo.numElements);
      // console.log(bufferInfo.numElements);

      requestAnimationFrame(drawScene);
    }
  }

  main();
</script>

</html>